## 概述
- JS的主线程是单线程，ajax，定时器，都是多线程
- Node.js 使用了事件驱动（内部靠异步实现，一个事完成了，会通知）、非阻塞式 I/O 的模型（非阻塞=异步）

## Node场景

### 1.普通调用
- 客户端发起请求，服务器响应，开启一个线程，等待结果返回，发起若干请求，并发量很高，每次开线程性能不好
- 线程池：完成会释放线程，复用线程，但是线程池里线程数量有限（多线程同步）
- 多线程的处理方式：
  - abc三个线程处理同一文件：b操作，文件上锁，b操作完，a操作，文件上锁，最后c操作
  - abc分别处理ABC三个文件：a处理一会儿A，切换到b处理一会儿B，时间片到了就切换上下文

### 2.Node中
- Node中，客户端访问服务器，发完请求，主线程释放，操作是异步的，发了请求就不管了，主线程去处理下一个请求的发送
- 请求返回，通过事件返回（回调方式）的方式，通知这个请求已经完成，主线程回去处理返回
- 简单情况下，可以用一个线程处理
- 如果有复杂处理，时间很长，新的请求就会阻塞，上一个不动了
- 单线程不能处理CPU密集型，在高并发，I/O密集场景有优势
- Node可以开多线程，实质上是开了若干子进程

> Node中间层调用Java接口不存在跨域，跨域只存在于浏览器和服务端之间，用中间层解决跨域，Node中处理跨域

## 阻塞和非阻塞，针对的是调用者的状态，此时能不能去干别的事
- 我调用了一个方法之后的状态，比如调用fs.readFile，不会去等待，可以去先执行别的


## 同步异步，针对的是被调用者
- 我调用了一个方法 ，这个方法会给我说他是同步的还是异步的


## 异步非阻塞 
 - 我调用了一个方法，这个方法是异步的，我不想要等待这个方法执行完毕


> 单线程缺陷：http 第一个请求 要计算 100万个数相加 第二个请求来了，需要等待第一个人计算完成


https://nodejs.org/zh-cn/docs/guides/event-loop-timers-and-nexttick/